---
title: "rs-synthesis"
date: "`r Sys.time()`"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '4'
    toc_float: yes
    number_sections: true
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Load packages
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra)
library(forcats)
library(DT)
library(metafor)
library(PerformanceAnalytics)
library(MuMIn)
library(dmetar)

theme_set(theme_minimal())

# Read in SRDB and filter out bad values using the Quality_flag column
srdb_raw <- read.csv("./rs/srdb-data.csv") %>% as_tibble()

# Read in new studies 2018-2021 that SRDB doesn't have yet
read_csv("./rs/Rs Studies 2018+ - Water Manipulation.csv",
         col_types = "cdddcdcccdcccdddddddddddc") %>% 
  select(Study_number, Record_number, Author, Study_midyear, Latitude, Ecosystem_type, 
         Manipulation, Manipulation_level, Meas_method, Soil_type,
         Rs_annual, Rh_annual, Rs_growingseason, Soil_drainage, Elevation) -> new_studies

srdb_raw %>% 
  select(Study_number, Record_number, Author, Study_midyear, Latitude, Ecosystem_type, 
         Manipulation, Manipulation_level, Meas_method, Species, Soil_type,
         Rs_annual, Rh_annual, Rs_growingseason, Soil_drainage, Soil_clay, Elevation, Quality_flag)  %>% 
  filter(!grepl("Q1[0-5]", Quality_flag)) %>% 
  bind_rows(new_studies) -> srdb

read_csv("rs/Variance and N - Water manipulations.csv", skip = 2,
         col_types = "ddcdccccdcccdddddddddddc") %>% #filter(Study_number==10526) %>% 
  select(Study_number, Record_number, N, OtherFactor, Longitude, SD_Rs_annual,	SD_Rh_annual, 
         SD_Rs_growingseason, Percent_control, SM_mean, SM_sd) %>% 
  left_join(srdb, by = c("Study_number", "Record_number")) %>% 
  mutate(Manipulation = case_when(
    Percent_control < 100 ~ "Drought",
    Percent_control > 100 ~ "Irrigation",
    Percent_control == 100 ~ "Control",
    TRUE ~ NA_character_)) -> dat_rs
```

# Manipulation Type Summaries {.tabset .tabset-pills}

## Water manipulations {.tabset}

```{r filter-manipulations, message = FALSE}

# Filter for studies with water manipulations
grep_string <- "^(Irrigat[a-z]*|Drought|Precipitation amount change)$"
srdb %>% 
  # Studies with manipulations that start with "Irrigat" or "Drought" or are "Precipitation amount change"
  filter(grepl(grep_string, Manipulation, ignore.case = TRUE)) %>% 
  distinct(Study_number) %>% 
  left_join(srdb, by = "Study_number") %>%
  # Filter for rows with control and drought rows
  group_by(Study_number) %>% 
  filter(Manipulation == "None" |
           grepl(grep_string, Manipulation, ignore.case = TRUE))  -> water_manipulations

# Summarize and count the number of studies
water_manipulations %>% 
  group_by(Ecosystem_type) %>% 
  summarise(n_studies = length(unique(Study_number)), .groups = "drop") %>% 
  mutate(M_Type = "Water manipulation") %>% 
  arrange(desc(n_studies)) %>% 
  rename(Ecosystem_Type = Ecosystem_type) %>% 
  select(M_Type, Ecosystem_Type, n_studies) -> wm_summary

# The SRDB and google sheet data have control and manipulations from the same
# study in different rows, which isn't what we want
# Rebuild the data frame to meet metafor requirements: for a given study,
# the control and treatment values are in the same row

# Construct the control data frame
# Remove duplicate control record from a study (reference respiration from pre-treatment years)
dat_rs %>% 
  filter(Manipulation == "Control", Record_number != "2368") %>% 
  select(-Record_number, -Author, -Manipulation, -Manipulation_level, -N, -SM_mean, -SM_sd)->
  controls

# Isolate the control mean and standard deviations; reshape; and join together
controls %>% 
  select(-starts_with("SD_"), -Percent_control) %>% 
  pivot_longer(cols = c(Rs_annual, Rh_annual, Rs_growingseason), 
               names_to = "depvar", values_to = "Control_Resp") ->
  cont_mean

controls %>% 
  select(-Rs_annual, -Rh_annual, -Rs_growingseason, -Percent_control) %>% 
  pivot_longer(cols = c(SD_Rs_annual, SD_Rh_annual, SD_Rs_growingseason),
               names_to = "depvar", values_to = "Control_SD") %>% 
  mutate(depvar = gsub("SD_", "", depvar)) ->
  cont_sd

meta_control <- cont_mean
meta_control$Control_SD <- cont_sd$Control_SD
meta_control <- filter(meta_control, !is.na(Control_Resp))

# and the same thing with the manipulation data frame
dat_rs %>% 
  filter(Manipulation != "Control") %>% 
  select(-starts_with("SD_")) %>% 
  pivot_longer(cols = c(Rs_annual, Rh_annual, Rs_growingseason), 
               names_to = "depvar", values_to = "Manip_Resp") ->
  manip_mean

dat_rs %>% 
  filter(Manipulation != "Control") %>% 
  select(-Rs_annual, -Rh_annual, -Rs_growingseason) %>% 
  pivot_longer(cols = c(SD_Rs_annual, SD_Rh_annual, SD_Rs_growingseason), 
               names_to = "depvar", values_to = "Manip_SD") %>% 
  mutate(depvar = gsub("SD_", "", depvar)) ->
  manip_sd

meta_manip <- manip_mean
meta_manip$Manip_SD <- manip_sd$Manip_SD
meta_manip <- filter(meta_manip, !is.na(Manip_Resp))

# Stop for a little defensive programming and qa/qc
# Every study in the manipulation data frame should have an entry in the control one
# (but the converse is not necessarily true)
sn_diff <- setdiff(meta_manip$Study_number, meta_control$Study_number)
stopifnot(length(sn_diff) == 0)

# ...and join with the manipulation data
meta_manip %>% 
  select(-Quality_flag) %>% 
  left_join(meta_control, 
            by = c("Study_number", "Study_midyear", "Ecosystem_type",
                   "Latitude", "Longitude", "OtherFactor", "Meas_method", "Species",
                   "Soil_type", "Soil_drainage", "Soil_clay", "Elevation", "depvar")) %>% 
  filter(!is.na(Manip_Resp)) %>% 
  rename("Variable" = "depvar") ->
  meta_df


#add study duration
meta_df %>%
  group_by(Study_number, OtherFactor, Ecosystem_type) %>%
  mutate(Duration = Study_midyear - min(Study_midyear)) -> meta_df


# summarize missing data, 83 studies in dataset

#34 studies are missing elevation
meta_df %>% 
  group_by(Elevation) %>% 
  summarise(n_studies = length(unique(Study_number)), .groups = "drop") %>% 
  arrange(desc(n_studies)) %>% 
  select(Elevation, n_studies) -> Elevation_summary


#63 studies missing clay
###think about how to add more clay data
meta_df %>% 
  group_by(Soil_clay) %>% 
  summarise(n_studies = length(unique(Study_number)), .groups = "drop") %>% 
  arrange(desc(n_studies)) %>% 
  select(Soil_clay, n_studies) -> Clay_summary

###compute effect sizes
#compute effect sizes
metadat <- escalc(measure = "ROM",
                  m1i = Manip_Resp, m2i = Control_Resp, 
                  sd1i = Manip_SD, sd2i = Control_SD,
                  n1i = N, n2i = N, 
                  slab = paste(Study_number, Author, Study_midyear),
                  data = meta_df)


```


```{r diagnostic-plots}
metadat %>%
  group_by(Ecosystem_type, Manipulation) %>%
  count() -> Ecosystem_summary

ggplot(metadat) + geom_histogram(aes(yi, fill=Manipulation), position = "identity") +
  facet_grid(Variable~.)

ggplot(metadat, aes(yi, color = Manipulation)) + 
  geom_density(na.rm = TRUE) + facet_grid(Variable~., scales = "free")

ggplot(metadat, aes(yi, fct_reorder(paste(Study_number, Author), Percent_control), color = Manipulation)) +
   geom_vline(xintercept = 0, colour = "black") +
  geom_point() + geom_errorbarh(aes(xmax = yi + vi, xmin = yi - vi))

#summarize mean effect size, 95%CI, and count by year of study (and manipulation type)

lower_ci <- function(mean, se, n, conf_level = 0.95){
  lower_ci <- mean - qt(1 - ((1 - conf_level) / 2), n - 1) * se
}
upper_ci <- function(mean, se, n, conf_level = 0.95){
  upper_ci <- mean + qt(1 - ((1 - conf_level) / 2), n - 1) * se
}

test <- metadat %>%
  group_by(Manipulation, Duration) %>%
  summarise(average = mean(yi, na.rm = TRUE),
            ssd = sd(yi, na.rm = TRUE),
            count = n()) %>%
  mutate(se = ssd/sqrt(count),
         lower_ci = lower_ci(average, se, count),
         upper_ci = upper_ci(average, se, count))

ggplot(test, aes(average, Duration, label = count)) + 
  geom_vline(xintercept = 0) +
  geom_errorbarh(aes(xmax = upper_ci, xmin = lower_ci,
                     na.rm = TRUE)) +
  geom_point(size = 4, na.rm = TRUE) + 
  scale_y_continuous(breaks=seq(0,13,1)) +
  facet_grid(.~Manipulation) + geom_label()

```

# Prep for model run

## Check for Colinearity in potential modifiers

Ben help with getting this sorted by manipulation.
There is correlation between Duration and Latitude,
but we don't need to worry because Latitude is not
an important modifier.

```{r}

metadat[,c("Duration","Percent_control","Latitude")] %>% chart.Correlation()

```

# Rank Modifiers
##for Irrigation
```{r}

#rank importance of modifiers for two manipulations
multimodel.inference(TE = "yi", seTE = "vi",
                     data = metadat[metadat$Manipulation == "Irrigation",],
                     predictors = c("Ecosystem_type", "Duration", "Percent_control", "Soil_drainage"),
                     interaction = TRUE)
```

#Now for Drought

```{r}

multimodel.inference(TE = "yi", seTE = "vi",
                     data = metadat[metadat$Manipulation == "Drought",],
                     predictors = c("Ecosystem_type", "Duration", "Percent_control", "Soil_drainage"),
                     interaction = TRUE)

```



```{r do_ma, message = FALSE}

do_ma <- function(dat, condition, dv, output = TRUE) {
  dat %>% 
    filter(Manipulation == condition, Variable == dv) -> 
    dat_condition
  
  cat("condition = ", condition, "\n")
  cat("var = ", dv, "\n")
  cat("N = ", nrow(dat_condition), "\n")
  cat("Percent control values:\n")
  print(summary(dat_condition$Percent_control))
  
  # Construct the meta-analysis variables and run the MA
  metadat <- escalc(measure = "ROM",
                    m1i = Manip_Resp, m2i = Control_Resp, 
                    sd1i = Manip_SD, sd2i = Control_SD,
                    n1i = N, n2i = N, 
                    slab = paste(Study_number, Author, Study_midyear),
                    data = dat_condition)
  
  # Arrange by response ratio
  metadat <- metadat[order(metadat$yi),]
  
  if(nrow(metadat) < 10) {
    return(list(metadata = metadat, mam = NULL))  
  }
  
  # BBL TODO: build formula dynamically and have a single model fit
  if(length(unique(metadat$Soil_drainage)) > 1) {
    mam <- rma(yi, vi, 
               mods = ~ Soil_drainage + Ecosystem_type +  Percent_control, 
               data = metadat)
  } else {
    mam <- rma(yi, vi, 
               mods = ~ Ecosystem_type +  Percent_control, 
               data = metadat)
  } 
  
  if(output) {
    # Diagnostics
    print(summary(mam))
    forest.rma(mam)
    title(paste(condition, dv))
    plot(mam)
  }
  invisible(list(metadat = metadat, mam = mam))
}
```

### Irrigation Results

```{r irrigation}
res_irrigation <- rma.mv(yi, vi, random = ~ 1|Study_number,
              mods = ~Ecosystem_type*Duration + Soil_drainage,
              method = "ML",
           data = metadat,
           subset = Manipulation == "Irrigation")
print(summary(res_irrigation))
    profile(res_irrigation)
    forest.rma(res_irrigation)
    funnel(res_irrigation)
    #would be nice to run different versions of the model and see a print out of the lower AICc with the chosen modifiers
  
    
metadat %>%
  group_by(Manipulation, Ecosystem_type) %>%
  summarise(average = mean(yi, na.rm = TRUE),
            ssd = sd(yi, na.rm = TRUE),
            count = n()) %>%
  mutate(se = ssd/sqrt(count),
         lower_ci = lower_ci(average, se, count),
         upper_ci = upper_ci(average, se, count))-> Ecosystem_effect

ggplot(Ecosystem_effect, aes(average, Ecosystem_type, label = count)) + 
  geom_vline(xintercept = 0) +
  geom_errorbarh(aes(xmax = upper_ci, xmin = lower_ci,
                     na.rm = TRUE)) +
  geom_point(size = 4, na.rm = TRUE) + 
  facet_grid(.~Manipulation) + geom_label()
    
#Want to make a graph using the effect sizes, how to do that?    
    
```

### Drought Results

```{r drought}
res_drought <- rma.mv(yi, vi, random = ~ 1|Study_number,
              mods = ~Ecosystem_type + Percent_control + Duration,
              method = "ML",
           data = metadat,
           subset = Manipulation == "Drought")
print(summary(res_drought))
    profile(res_drought)
    forest.rma(res_drought)
    funnel(res_drought)
```

### Effect of Duration

```{r}
ggplot(metadat,
       aes(Duration, yi, color=Ecosystem_type)) + 
  geom_hline(yintercept = 0)+
  geom_point(na.rm = TRUE) + geom_smooth(method = lm, aes(fill = Ecosystem_type)) +
  facet_grid(Manipulation~.) + theme(legend.position = "bottom")
```

### Effect of Intensityl

```{r}
ggplot(metadat,
       aes(Percent_control, yi)) + 
  geom_hline(yintercept = 0) +
  geom_point(na.rm = TRUE, aes(color = Ecosystem_type)) + geom_smooth(method = lm) +
  facet_grid(.~Manipulation, scales = "free") + theme(legend.position = "bottom") + ggtitle("Over-all Trend of Percent Control")

ggplot(metadat[metadat$Percent_control < 300,],
       aes(Percent_control, yi)) + 
  geom_hline(yintercept = 0) +
  geom_point(na.rm = TRUE, aes(color = Ecosystem_type)) + geom_smooth(method = lm) +
  facet_grid(.~Manipulation, scales = "free") + theme(legend.position = "bottom") + ggtitle("Over-all Trend of Percent Control, excluding really wet study")

```

## Contrasting Soil Drainage

```{r filter-soildrainage, message = FALSE}

drainage <- c("Dry", "Wet")
# Need studies that have BOTH dry and wet drainage

srdb %>%
  group_by(Study_number) %>%
  filter(grepl(paste(drainage, collapse = "|"), x = Soil_drainage)) %>%
  # Count the number of unique soil drainage types per study
  summarise(n_drain = length(unique(Soil_drainage)), .groups = "drop") %>%
  # We only want studies with 2 or more soil drainage types
  filter(n_drain > 1) %>%
  left_join(srdb, by = "Study_number") -> drainage_type

drainage_type %>%
  group_by(Ecosystem_type) %>%
  summarise(n_studies = length(unique(Study_number)), .groups = "drop") %>%
  mutate(M_Type = "Soil drainage") %>%
  arrange(desc(n_studies)) %>%
  rename(Ecosystem_Type = Ecosystem_type) %>%
  select(M_Type, Ecosystem_Type, n_studies) -> drain_summary
# 
# kable(drain_summary) %>% kable_styling(full_width = FALSE)
# 
# drainage_type %>% 
#   filter(Ecosystem_type %in% c("Forest", "Grassland", "Agriculture")) %>% 
#   group_by(Ecosystem_type, Soil_drainage) %>% 
#   summarise(n_obs = n(), .groups = "drop")
# 
# # Isolate soil "wet" row and use that as 'treatment' to compute response ratio
# drainage_type %>% 
#   filter(Manipulation == "None", Soil_drainage == "Wet") %>% 
#   group_by(Study_number, Ecosystem_type, Study_midyear) %>% 
#   summarise(Rs_wet = mean(Rs_annual, na.rm = TRUE), .groups = "drop") %>% 
#   filter(!is.na(Rs_wet)) %>% 
#   left_join(drainage_type, by = c("Study_number", "Ecosystem_type", "Study_midyear")) %>% 
#   filter(Soil_drainage == "Dry") %>% 
#   mutate(rr = log(Rs_wet / Rs_annual), 
#          Study = paste(Study_number, Author)) -> drainage_resp
# 
#   ggplot(drainage_resp, aes(x = rr, y = fct_reorder(Study, rr))) + 
#     geom_point(colour = "darkblue") + 
#     geom_vline(xintercept = 0, linetype = "dashed") + 
#     labs(x = "Response Ratio of Wet vs Dry (control) Soil Drainage", y = "Study") +
#     theme_light()

```

# Data Summaries

## Number of Studies Per Manipulation in All Ecosystem Types
```{r summary-table, message = FALSE}

#Are drought vs irrigiation studies evenly distributed among ecosystems?
# Maybe our strong predictors are a result of where studies take place
water_manipulations %>% 
  ungroup %>% 
  pivot_longer(Rs_annual:Rs_growingseason, names_to = "Variable", values_to = "Value") %>% 
  group_by(Ecosystem_type, Manipulation, Variable) %>%
  summarise(N_studies = sum(!is.na(Value))) %>% 
  pivot_wider(names_from = Variable, values_from = N_studies) %>% 
  DT::datatable()

# # Summary by level of manipulation
# water_manipulations %>% 
#   filter(Ecosystem_type %in% c("Forest", "Grassland", "Agriculture")) %>%
#   group_by(Ecosystem_type, Manipulation, Manipulation_level) %>% 
#   summarise(n_obs = n(), .groups = "drop")
# ```
```

# The End

```{r}
sessionInfo()
```

